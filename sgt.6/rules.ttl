# baseURI: http://sgt.6/rules
# imports: http://sgt.6/20160614/component-collection-all
# imports: http://sgt.6/explanations
# imports: http://sgt.6/tweaks
# imports: http://spinrdf.org/spinx
# imports: http://spinrdf.org/spl
# prefix: rules

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rules: <http://sgt.6/rules#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spinx: <http://spinrdf.org/spinx#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://sgt.6/rules>
  rdf:type owl:Ontology ;
  owl:imports <http://sgt.6/20160614/component-collection-all> ;
  owl:imports <http://sgt.6/explanations> ;
  owl:imports <http://sgt.6/tweaks> ;
  owl:imports <http://spinrdf.org/spinx> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "Created with TopBraid Composer"^^xsd:string ;
.
rules:aggregateReactiveLoadUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate rules:getLoadsContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
                    ] ;
                  sp:subject [
                      sp:varName "load"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    rdf:type sp:mul ;
                    sp:arg1 [
                        sp:varName "val"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "val"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive load demand uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the loads on the circuit
2. Intersect those loads with the entities supervised by the EM
3. For each resulting load, get the reactive demand uncertainty, and square it
4. Make it a floating point number
5. Sum all the values and return the square root of the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveLoads
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate rules:getLoadsContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
                    ] ;
                  sp:subject [
                      sp:varName "load"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the loads on the circuit
2. Intersect those loads with the entities supervised by the EM
3. For each resulting load, get the reactive power value
4. Make it a floating point number
5. Sum all the values and return the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveMeterUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:predicate rules:getMetersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject [
                sp:varName "meter"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasPowerReadingRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "noGenVal"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "genVal"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type rules:rIsGeneratorOnCircuit ;
                    sp:arg1 [
                        sp:varName "circuitBeyondMeter"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "genVal"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "noGenVal"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveMeters
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:predicate rules:getMetersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject [
                sp:varName "meter"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasPowerReadingRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "noGenVal"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "genVal"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type rules:rIsGeneratorOnCircuit ;
                    sp:arg1 [
                        sp:varName "circuitBeyondMeter"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "genVal"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "noGenVal"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveRouterUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate rules:getRoutersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:combineReactiveDemandUncertaintyFromC1AndC2 ;
                sp:arg1 [
                    sp:varName "router"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "em"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the routers on the circuit
2. Intersect those routers with the routers supervised by the EM
3. For each resulting router, sum the total reactive demand uncertainty flowing in Connection1, and the total reactive demand uncertainty flowing in Connection2
4. Make it a floating point number
5. Return the square root of the sum of the squares"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveRouters
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate rules:getRoutersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:combineReactiveDemandFromC1AndC2 ;
                sp:arg1 [
                    sp:varName "router"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "em"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the routers on the circuit
2. Intersect those routers with the routers supervised by the EM
3. For each resulting router, sum the total reactive demand flowing in Connection1, and the total demand flowing in Connection2
4. Make it a floating point number
5. Sum all the values and return the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveSubEMUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate rules:getEMsManagingCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "subEM"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg1 ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasCircuitOfAggregationRef> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:SeqPath ;
                    sp:path1 [
                        rdf:type sp:SeqPath ;
                        sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregateDemandRef> ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/standard_aggregations---collections_rulesets_and_aggregations#hasAggregateQuantityRef> ;
                      ] ;
                    sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                  ] ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the EMs contributing to the circuit
2. Intersect those EMs with the entities supervised by the EM
4. For each resulting EM, get the aggregateDemandUncertainty value
5. Return square root of the sum of the squares

Note: This presumes that the calling rule has verified the subEMs are ready (i.e. they have calculated their aggregateDemandUncertainty values)."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateReactiveSubEMs
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate rules:getEMsManagingCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "subEM"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg1 ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasCircuitOfAggregationRef> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:SeqPath ;
                    sp:path1 [
                        rdf:type sp:SeqPath ;
                        sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregateDemandRef> ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/standard_aggregations---collections_rulesets_and_aggregations#hasAggregateQuantityRef> ;
                      ] ;
                    sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityReactivePowerRef> ;
                  ] ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the EMs contributing to the circuit
2. Intersect those EMs with the entities supervised by the EM
4. For each resulting EM, get the reactiveAggregateDemand value
5. Make it a floating point number
6. Sum all the values and return the sum

Note: This presumes that the calling rule has verified the subEMs are ready (i.e. they have calculated their reactiveAggregateDemand values)."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealLoadUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate rules:getLoadsContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
                    ] ;
                  sp:subject [
                      sp:varName "load"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    rdf:type sp:mul ;
                    sp:arg1 [
                        sp:varName "val"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "val"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real load demand uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the loads on the circuit
2. Intersect those loads with the entities supervised by the EM
3. For each resulting load, get the real demand uncertainty, and square it
4. Make it a floating point number
5. Sum all the values and return the square root of the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealLoads
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate rules:getLoadsContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
                    ] ;
                  sp:subject [
                      sp:varName "load"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the loads on the circuit
2. Intersect those loads with the entities supervised by the EM
3. For each resulting load, get the real power value
4. Make it a floating point number
5. Sum all the values and return the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealMeterUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:predicate rules:getMetersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject [
                sp:varName "meter"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasPowerReadingRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "noGenVal"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "genVal"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type rules:rIsGeneratorOnCircuit ;
                    sp:arg1 [
                        sp:varName "circuitBeyondMeter"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "genVal"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "noGenVal"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealMeters
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:predicate rules:getMetersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "meter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentResourcesRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#hasPartRef> ;
              ] ;
            sp:subject spin:_arg2 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject [
                sp:varName "meter"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "val"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 [
                          rdf:type sp:SeqPath ;
                          sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasPowerReadingRef> ;
                          sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                        ] ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "val"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 0.0 ;
                sp:arg3 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "noGenVal"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuitBeyondMeter"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "genVal"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type rules:rIsGeneratorOnCircuit ;
                    sp:arg1 [
                        sp:varName "circuitBeyondMeter"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "genVal"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "noGenVal"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "newval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "newval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealRouterUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate rules:getRoutersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:combineRealDemandUncertaintyFromC1AndC2 ;
                sp:arg1 [
                    sp:varName "router"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "em"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the routers on the circuit
2. Intersect those routers with the routers supervised by the EM
3. For each resulting router, sum the total real demand uncertainty flowing in Connection1, and the total real demand uncertainty flowing in Connection2
4. Make it a floating point number
5. Return the square root of the sum of the squares"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealRouters
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate rules:getRoutersContributingToCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject spin:_arg2 ;
          ]
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:combineRealDemandFromC1AndC2 ;
                sp:arg1 [
                    sp:varName "router"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "em"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the routers on the circuit
2. Intersect those routers with the routers supervised by the EM
3. For each resulting router, sum the total demand flowing in Connection1, and the total demand flowing in Connection2
4. Make it a floating point number
5. Sum all the values and return the sum"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealSubEMUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate rules:getEMsManagingCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "subEM"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg1 ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasCircuitOfAggregationRef> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:SeqPath ;
                    sp:path1 [
                        rdf:type sp:SeqPath ;
                        sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregateDemandRef> ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/standard_aggregations---collections_rulesets_and_aggregations#hasAggregateQuantityRef> ;
                      ] ;
                    sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                  ] ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasUncertainty> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the EMs contributing to the circuit
2. Intersect those EMs with the entities supervised by the EM
4. For each resulting EM, get the aggregateDemandUncertainty value
5. Return square root of the sum of the squares

Note: This presumes that the calling rule has verified the subEMs are ready (i.e. they have calculated their aggregateDemandUncertainty values)."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:aggregateRealSubEMs
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate rules:getEMsManagingCircuit ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEM"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
            sp:subject [
                sp:varName "em"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
            sp:subject [
                sp:varName "subEM"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg1 ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasCircuitOfAggregationRef> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:SeqPath ;
                    sp:path1 [
                        rdf:type sp:SeqPath ;
                        sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregateDemandRef> ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/standard_aggregations---collections_rulesets_and_aggregations#hasAggregateQuantityRef> ;
                      ] ;
                    sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                  ] ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
              ] ;
            sp:subject [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Find the EMs contributing to the circuit
2. Intersect those EMs with the entities supervised by the EM
4. For each resulting EM, get the aggregateDemand value
5. Make it a floating point number
6. Sum all the values and return the sum

Note: This presumes that the calling rule has verified the subEMs are ready (i.e. they have calculated their aggregateDemand values)."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:allGeneratorsConnected
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              rdf:type sp:TriplePath ;
                              sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/generator_component---device_and_model_components#Generator> ;
                              sp:path [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 rdf:type ;
                                  sp:path2 [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                ] ;
                              sp:subject [
                                  sp:varName "gen"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "val"^^xsd:string ;
                                ] ;
                              sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/generator_component---device_and_model_components#hasOutputRef> ;
                              sp:subject [
                                  sp:varName "gen"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 "false"^^xsd:boolean ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Check if every Generator in the model is linked to a ConnectionPoint. This presumes that the ConnectionPoint is linked to a Circuit. This predicate is used to prevent the firing of rules that depend on the associations being present, until they are indeed present."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:allLoadsConnected
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              rdf:type sp:TriplePath ;
                              sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#Load> ;
                              sp:path [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 rdf:type ;
                                  sp:path2 [
                                      rdf:type sp:ModPath ;
                                      sp:modMax -2 ;
                                      sp:modMin 0 ;
                                      sp:subPath rdfs:subClassOf ;
                                    ] ;
                                ] ;
                              sp:subject [
                                  sp:varName "load"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "val"^^xsd:string ;
                                ] ;
                              sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasInputRef> ;
                              sp:subject [
                                  sp:varName "load"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 "false"^^xsd:boolean ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Check if every Load in the model is linked to a ConnectionPoint. This presumes that the ConnectionPoint is linked to a Circuit.  This predicate is used to prevent the firing of rules that depend on the associations being present, until they are indeed present."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:calculateAggregateReactiveDemand
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#hasEMPresentData> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandAggregation> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Add the values of hasReactiveComputedAggregation from DemandFromMeters, the DemandFromUnmeteredLoads, DemandFromRouters and the DemandFromSubEMs for the relevant Circuit and EMPresentData instance
2. Make it a floating point number

Note: This presumes all four input AggregateDemands have been calculated, and this has been checked by the calling rule."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:calculateAggregateReactiveDemandUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#hasEMPresentData> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive demand uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Add the squares of DemandFromMeters, the DemandFromUnmeteredLoads, DemandFromRouters and the DemandFromSubEMs for the relevant Circuit and EMPresentData instance
2. Take the square root and make it a floating point number

Note: This presumes all three input AggregateDemands have been calculated, and this has been checked by the calling rule."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:calculateAggregateRealDemand
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Sum ;
                sp:expression [
                    sp:varName "fval"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#hasEMPresentData> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandAggregation> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Add the DemandFromMeters, the DemandFromUnmeteredLoads, DemandFromRouters and the DemandFromSubEMs for the relevant Circuit and EMPresentData instance
2. Make it a floating point number

Note: This presumes all three input AggregateDemands have been calculated, and this has been checked by the calling rule."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:calculateAggregateRealDemandUncertainty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:Sum ;
                    sp:expression [
                        sp:varName "fval"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:varName "aggVal"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#hasEMPresentData> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "ad"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:mul ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "squareval"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "squareval"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The EM supervising the loads"^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real demand uncertainty for a given circuit (arg1) and EMPresentData (arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the circuit
arg2: the EMPresentData instance (a proxy for the EM)
Procedure:
1. Add the squares of DemandFromMeters, the DemandFromUnmeteredLoads, DemandFromRouters and the DemandFromSubEMs for the relevant Circuit and EMPresentData instance
2. Take the square root and make it a floating point number

Note: This presumes all three input AggregateDemands have been calculated, and this has been checked by the calling rule."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:ceAlreadyHasUsagePoint
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "someRelation"^^xsd:string ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "usagePoint"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasMeasuredAtRef> ;
            sp:subject [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#EMUsagePoint> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "usagePoint"^^xsd:string ;
              ] ;
          ]
        ) ;
      rdfs:comment "Check if there is already a UsagePoint defined for some other measurement of the associated ComponentElement"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "false"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#ComponentElement> ;
      rdfs:comment "The argument should be an instance of a descendant of ComponentElement"^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "This version assumes ?arg1 is an instance of a descendant of ComponentElement. Both PowerMeasurementSets and PowerMeasurementQuantities point to a UsagePoint, so you really need to check all branches."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:circuitHasOnlyLoads
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "gen"^^xsd:string ;
                                ] ;
                              sp:predicate rules:getGeneratorsContributingToCircuit ;
                              sp:subject spin:_arg1 ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "em"^^xsd:string ;
                                ] ;
                              sp:predicate rules:getEMsManagingCircuit ;
                              sp:subject spin:_arg1 ;
                            ]
                            [
                              rdf:type sp:TriplePath ;
                              sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/primitive_data_types---common_primitive_types_classes_and_enumerations#true> ;
                              sp:path [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 [
                                      rdf:type sp:SeqPath ;
                                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
                                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                                    ] ;
                                  sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasHasElectricalGenerators> ;
                                ] ;
                              sp:subject [
                                  sp:varName "em"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 "false"^^xsd:boolean ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The circuit to be interrogated"^^xsd:string ;
    ] ;
  rdfs:comment "THIS FUNCTION IS NOT YET WORKING........Check that the given Circuit (?arg1) only has Loads, or ComponentElements that are managed by EMs assuring that no Generators are present."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:combineReactiveDemandFromC1AndC2
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "fval"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "demand1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "demand2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:add ;
                sp:arg1 [
                    sp:varName "demand1"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "demand2"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power for a given router (arg1) and it's supervising EM (?arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the router
arg2: the supervising EM
Procedure:
1. Find the two Circuits feeding in to the Router: Circuit1 and Circuit2 
2. Calculate the total reactive demand of each of these two Circuits
3. Sum these two demand values
4. Make it a floating point number"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:combineReactiveDemandUncertaintyFromC1AndC2
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "fval"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "du1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "du2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedReactiveDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:add ;
                    sp:arg1 [
                        rdf:type sp:mul ;
                        sp:arg1 [
                            sp:varName "du1"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "du1"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:mul ;
                        sp:arg1 [
                            sp:varName "du2"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "du2"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate reactive power uncertainty for a given router (arg1) and it's supervising EM (?arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the router
arg2: the supervising EM
Procedure:
1. Find the two Circuits feeding in to the Router: Circuit1 and Circuit2 
2. Find the total demand uncertainty of each of these two Circuits
3. Sum the square of the two demand uncertainty values
4. Take the square root
5. Make it a floating point number, and return"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:combineRealDemandFromC1AndC2
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "fval"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "demand1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "demand2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandAggregation> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:add ;
                sp:arg1 [
                    sp:varName "demand1"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "demand2"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power for a given router (arg1) and it's supervising EM (?arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the router
arg2: the supervising EM
Procedure:
1. Find the two Circuits feeding in to the Router: Circuit1 and Circuit2 
2. Calculate the total demand of each of these two Circuits
3. Sum these two demand values
4. Make it a floating point number"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:combineRealDemandUncertaintyFromC1AndC2
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "fval"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "du1"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://sgt.6/explanations#AggregateDemand> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasCircuit> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "du2"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#hasComputedRealDemandUncertaintyAggregation> ;
            sp:subject [
                sp:varName "aggDemand2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:sqrt ;
                sp:arg1 [
                    rdf:type sp:add ;
                    sp:arg1 [
                        rdf:type sp:mul ;
                        sp:arg1 [
                            sp:varName "du1"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "du1"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:mul ;
                        sp:arg1 [
                            sp:varName "du2"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "du2"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "val"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                sp:arg1 [
                    sp:varName "val"^^xsd:string ;
                  ] ;
                sp:arg2 xsd:float ;
              ] ;
            sp:variable [
                sp:varName "fval"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  spin:returnType xsd:float ;
  rdfs:comment "Calculate the aggregate real power uncertainty for a given router (arg1) and it's supervising EM (?arg2)"^^xsd:string ;
  rdfs:comment """Documentation:
arg1: the router
arg2: the supervising EM
Procedure:
1. Find the two Circuits feeding in to the Router: Circuit1 and Circuit2 
2. Find the total demand uncertainty of each of these two Circuits
3. Sum the square of the two demand uncertainty values
4. Take the square root
5. Make it a floating point number, and return"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:countInstancesOnProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Count ;
                sp:expression [
                    sp:varName "inst"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "count"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "inst"^^xsd:string ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  rdfs:comment "Count how many matches there are for <?subject ?predicate ?anything>, given ?subject and ?predicate as arguments"^^xsd:string ;
  rdfs:comment "This isn't being used, because it doesn't work for property paths, only for individual properties."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:countSubordinateEMempdDemandValues
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Count ;
                sp:expression [
                    sp:varName "val"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "count"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:SeqPath ;
                    sp:path1 [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 [
                                rdf:type sp:SeqPath ;
                                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
                                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
                              ] ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregateDemandRef> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/standard_aggregations---collections_rulesets_and_aggregations#hasAggregateQuantityRef> ;
                      ] ;
                    sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
                  ] ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given an EM, count how many EMPresentData instances that are associated with EMs that are direct subordinates of the arg1 EM, have values for presentDemand"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:countSubordinateEMempds
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Count ;
                sp:expression [
                    sp:varName "subEmpd"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "count"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "subEmpd"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given an EM, count how many EMPresentData instances are associated with EMs that are direct subordinates of the arg1 EM"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:doIManageGeneratorsOnThisCircuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "gen"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasGeneratorsRef> ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/generator_component---device_and_model_components#Generator> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 [
                    rdf:type sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdfs:subClassOf ;
                  ] ;
              ] ;
            sp:subject [
                sp:varName "gen"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "gen"^^xsd:string ;
              ] ;
            sp:predicate rules:getGeneratorsContributingToCircuit ;
            sp:subject spin:_arg2 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#EM> ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """This function takes two arguments:
arg1: An instance of an EM
arg2: An instance of a Circuit
It will check if \"EM\" is responsible for any Generators on \"Circuit\", and return a boolean value"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:doIManageLoadsOnThisCircuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasLoadsRef> ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#Load> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 [
                    rdf:type sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdfs:subClassOf ;
                  ] ;
              ] ;
            sp:subject [
                sp:varName "load"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "load"^^xsd:string ;
              ] ;
            sp:predicate rules:getLoadsContributingToCircuit ;
            sp:subject spin:_arg2 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#EM> ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """This function takes two arguments:
arg1: An instance of an EM
arg2: An instance of a Circuit
It will check if \"EM\" is responsible for any Loads on \"Circuit\", and return a boolean value"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:doIManageRoutersOnThisCircuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#EnergyRouter> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 [
                    rdf:type sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdfs:subClassOf ;
                  ] ;
              ] ;
            sp:subject [
                sp:varName "router"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "router"^^xsd:string ;
              ] ;
            sp:predicate rules:getRoutersContributingToCircuit ;
            sp:subject spin:_arg2 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#EM> ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """This function takes two arguments:
arg1: An instance of an EM
arg2: An instance of a Circuit
It will check if \"EM\" is responsible for any Routers on \"Circuit\", and return a boolean value"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:findSuperclassWithNamedProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "parent"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "parent"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 1 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "prop"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdfs:subClassOf ;
                sp:path2 owl:onProperty ;
              ] ;
            sp:subject [
                sp:varName "parent"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:localname ;
                sp:arg1 [
                    sp:varName "prop"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "pname"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "pname"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The class having a specified property to explore"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string name of the property to search superclasses for"^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:subClassOf spin:Functions ;
.
rules:getAnInstanceOfClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "instance"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Find any instance of a Class and return it. "^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:getC1Circuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "c1"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "c1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given a Router (?arg1), return the Circuit connected to C1 of the Router."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:getC1andC2Circuits
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "circuit"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "c1"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "c2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "circuit"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "c1"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "c2"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getC2Circuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "c2"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "c2"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given a Router (?arg1), return the Circuit connected to C2 of the Router."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:getCircuitsAffectedByThisEM
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "circuit"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasLoadsRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasInputRef> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasGeneratorsRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/generator_component---device_and_model_components#hasOutputRef> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasMetersRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasInputRef> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasMetersRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection0Ref> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection1Ref> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "circuit"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 [
                            rdf:type sp:SeqPath ;
                            sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEnergyRouterRef> ;
                            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                          ] ;
                        sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                      ] ;
                    sp:subject spin:_arg1 ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "This returns all circuits connected to entities managed by this EM (arg1)."^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getEMsManagingCircuit
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "em"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasCircuitOfAggregationRef> ;
            sp:subject [
                sp:varName "aggProp"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "em"^^xsd:string ;
              ] ;
            sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
            sp:subject [
                sp:varName "aggProp"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  rdfs:comment "This returns all EMs (Energy Managers) that manage one or more entities connected to Circuit (?arg1)."^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getGeneratorsContributingToCircuit
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "generator"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
            sp:subject [
                sp:varName "connection"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "connection"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/generator_component---device_and_model_components#hasOutputRef> ;
            sp:subject [
                sp:varName "generator"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getLoadsContributingToCircuit
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "load"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
            sp:subject [
                sp:varName "connection"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "connection"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasInputRef> ;
            sp:subject [
                sp:varName "load"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#Load> ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdf:type ;
                sp:path2 [
                    rdf:type sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdfs:subClassOf ;
                  ] ;
              ] ;
            sp:subject [
                sp:varName "load"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  rdfs:comment """Documentation:
1. Find all the ConnectionPoints for a Circuit
2. Find all the entities that have those ConnectionPoints as their InputRef
3. Find those that are of type Load (or a subclass of Load)
4. Return all the resulting Loads"""^^xsd:string ;
  rdfs:comment "Find all instances of type Load connected to a given Circuit (arg1)"^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getMetersContributingToCircuit
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "meter"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
            sp:subject [
                sp:varName "connection"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "connection"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasInputRef> ;
            sp:subject [
                sp:varName "meter"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  rdfs:comment "This returns all Meters that are on the \"downstream\" side of a Circuit, i.e. Meters that contribute a demand or supply to the Circuit passed as the argument. (Not meters that are on the grid side of the circuit)."^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getRoutersContributingToCircuit
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "router"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
            sp:subject [
                sp:varName "connection"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "connection"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection0Ref> ;
            sp:subject [
                sp:varName "router"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  rdfs:subClassOf spin:MagicProperties ;
.
rules:getUsagePoint
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "usagePoint"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "someRelation"^^xsd:string ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "usagePoint"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasMeasuredAtRef> ;
            sp:subject [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
          ]
          [
            sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#EMUsagePoint> ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "usagePoint"^^xsd:string ;
              ] ;
          ]
        ) ;
      rdfs:comment "Check if there is already a UsagePoint defined for some other measurement of the associated ComponentElement and return its URI"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "false"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/device---device_and_model_components#ComponentElement> ;
      rdfs:comment "The argument should be an instance of a descendant of ComponentElement"^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "This version assumes ?arg1 is an instance of a descendant of ComponentElement. Both PowerMeasurementSets and PowerMeasurementQuantities point to a UsagePoint, so you really need to check all branches."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:getValueOfProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "val"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  rdfs:comment "Given an instance (arg1), get the value of the specified property (arg2)"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:haveICalculatedSubCircuitAggregationsForThisRouter
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:getC1Circuit ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "circuit1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:getC2Circuit ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "circuit2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object <http://sgt.6/explanations#AggregateDemand> ;
                          sp:predicate rdf:type ;
                          sp:subject [
                              sp:varName "aggDemand1"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object spin:_arg1 ;
                          sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
                          sp:subject [
                              sp:varName "aggDemand1"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "circuit1"^^xsd:string ;
                            ] ;
                          sp:predicate <http://sgt.6/explanations#hasCircuit> ;
                          sp:subject [
                              sp:varName "aggDemand1"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object <http://sgt.6/explanations#AggregateDemand> ;
                          sp:predicate rdf:type ;
                          sp:subject [
                              sp:varName "aggDemand2"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object spin:_arg1 ;
                          sp:predicate <http://sgt.6/explanations#supportsComponentElement> ;
                          sp:subject [
                              sp:varName "aggDemand2"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "circuit2"^^xsd:string ;
                            ] ;
                          sp:predicate <http://sgt.6/explanations#hasCircuit> ;
                          sp:subject [
                              sp:varName "aggDemand2"^^xsd:string ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
                sp:arg3 "false"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
    ] ;
  rdfs:comment "Given an instance of EM (?arg1), and EnergyRouter (?arg2) check if the aggregations for the router downstream circuits have been calculated. This boolean function is used to ensure an EM doesn't calculate an aggregation containing a Router until the EM's aggregations for the Router's downstream Circuits have been calculated. A returned value of \"true\" means the aggregations have been calculated."^^xsd:string ;
  rdfs:comment "NEED TO RETHINK THE LOGIC OF THIS TO ENSURE THAT ALL THE REQUIRED TRIPLES EXIST, NOT JUST AT LEAST ONE."^^xsd:string ;
  rdfs:comment """Procedure:
1. check if aggregations have been done on the subCircuits. If so, then TRUE, else FALSE."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
<http://sgt.6/rules#isClass.Propertyoptional>
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "restriction"^^xsd:string ;
              ] ;
            sp:predicate rdfs:subClassOf ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate owl:onProperty ;
            sp:subject [
                sp:varName "restriction"^^xsd:string ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate owl:minCardinality ;
            sp:subject [
                sp:varName "restriction"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType owl:Class ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property has a restriction of min=0"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:measurementAlreadyHasUsagePoint
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate [
                sp:varName "rel"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "entity"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "someRelation"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "entity"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "usagePoint"^^xsd:string ;
              ] ;
            sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasMeasuredAtRef> ;
            sp:subject [
                sp:varName "someMeasurement"^^xsd:string ;
              ] ;
          ]
        ) ;
      rdfs:comment "Check if there is already a UsagePoint defined for some other measurement of the associated ComponentElement"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The class having a specified property to explore"^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "This version assumes ?arg1 is an instance of superclass Measurement. Both PowerMeasurementSets and PowerMeasurementQuantities point to a UsagePoint, so you really need to check all branches."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:optimisticFindSuperclassWithNamedProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "parent"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:namespace ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "propNamespace"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "parent"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object owl:Class ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "parent"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:namespace ;
                sp:arg1 [
                    sp:varName "parent"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "parentNamespace"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "parentNamespace"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "propNamespace"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "prop"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 rdfs:subClassOf ;
                sp:path2 owl:onProperty ;
              ] ;
            sp:subject [
                sp:varName "parent"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "prop"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The class having a specified property to explore"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The string name of the property to search superclasses for"^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:subClassOf spin:Functions ;
.
rules:rIsGeneratorOnCircuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "answer"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "gen"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getGeneratorsContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "router"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getRoutersContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getMetersContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "mCircuit"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "gen"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 "true"^^xsd:boolean ;
                        sp:arg3 "false"^^xsd:boolean ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "router"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 "true"^^xsd:boolean ;
                        sp:arg3 "false"^^xsd:boolean ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "meter"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type rules:rIsGeneratorOnCircuit ;
                        sp:arg1 [
                            sp:varName "mCircuit"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg3 "false"^^xsd:boolean ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "answer"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """This function takes one argument:
arg1: An instance of a Circuit
It will recursively check if there is a Generator or Router on this Circuit, or a Generator or Router on any Circuit on the far side of any Meters contributing to this Circuit. The logic of looking for Routers is that when you have a Router, there must be a power supply of some sort on Connection1, so you don't need to keep checking."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:rIsLoadOnCircuit
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "answer"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "load"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getLoadsContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "router"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getRoutersContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "rCircuit"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energyrouter---energy_manager_component#hasConnection2Ref> ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                    ] ;
                  sp:subject [
                      sp:varName "router"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                  sp:predicate rules:getMetersContributingToCircuit ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "mCircuit"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:SeqPath ;
                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/meter_component---device_and_model_components#hasOutputRef> ;
                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#hasConnectedToRef> ;
                    ] ;
                  sp:subject [
                      sp:varName "meter"^^xsd:string ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "load"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 "true"^^xsd:boolean ;
                        sp:arg3 "false"^^xsd:boolean ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "router"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type rules:rIsLoadOnCircuit ;
                            sp:arg1 [
                                sp:varName "rCircuit"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg3 "false"^^xsd:boolean ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "meter"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type rules:rIsLoadOnCircuit ;
                        sp:arg1 [
                            sp:varName "mCircuit"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg3 "false"^^xsd:boolean ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "answer"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/other_common_classes---common_primitive_types_classes_and_enumerations#Circuit> ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """This function takes one argument:
arg1: An instance of a Circuit
It will recursively check if there is a Load on this Circuit, or on any Circuit on the far side of any Routers or Meters."""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:sqrt
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  spin:returnType xsd:float ;
  spinx:javaScriptCode "return Math.sqrt (arg1)"^^xsd:string ;
  rdfs:comment "Compute the square root of a number."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:subEMAggregationReady
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:countSubordinateEMempds ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "empdCount"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type rules:countSubordinateEMempdDemandValues ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "valueCount"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        sp:varName "empdCount"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "valueCount"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
                sp:arg3 "false"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given an EM (?arg1), check if all direct subordinate EMs have calculated their aggregation values. This boolean function is used to ensure a higher-level EM doesn't calculate an aggregation until all the subordinate EMs have already done so. A returned value of \"true\" means all direct subordinates have done so."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:subEMsHaveGenerators
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          rdf:type sp:TriplePath ;
                          sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/primitive_data_types---common_primitive_types_classes_and_enumerations#true> ;
                          sp:path [
                              rdf:type sp:SeqPath ;
                              sp:path1 [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 [
                                      rdf:type sp:SeqPath ;
                                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
                                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
                                    ] ;
                                  sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                                ] ;
                              sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasHasElectricalGenerators> ;
                            ] ;
                          sp:subject spin:_arg1 ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
                sp:arg3 "false"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment """Given an EM, check if any direct subordinate EMs have generators. Note that this assumes all subordinate EMs have been fully defined when this question is asked, which can be checked using the function rules:subEMsReady.
"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:subEMsHaveLoads
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          rdf:type sp:TriplePath ;
                          sp:object <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/primitive_data_types---common_primitive_types_classes_and_enumerations#true> ;
                          sp:path [
                              rdf:type sp:SeqPath ;
                              sp:path1 [
                                  rdf:type sp:SeqPath ;
                                  sp:path1 [
                                      rdf:type sp:SeqPath ;
                                      sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
                                      sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
                                    ] ;
                                  sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasAggregationMetadataRef> ;
                                ] ;
                              sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/key_energy_manager_concepts---energy_manager_component#hasHasLoads> ;
                            ] ;
                          sp:subject spin:_arg1 ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
                sp:arg3 "false"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment """Given an EM, check if any direct subordinate EMs have loads. Note that this assumes all subordinate EMs have been fully defined when this question is asked, which can be checked using the function rules:subEMsReady.
"""^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
rules:subEMsReady
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:exists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "sub"^^xsd:string ;
                                ] ;
                              sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasEMsRef> ;
                              sp:subject spin:_arg1 ;
                            ]
                          ) ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "emp"^^xsd:string ;
                                ] ;
                              sp:predicate <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/energy_manager_component---device_and_model_components#hasPresentAggregationDataRef> ;
                              sp:subject [
                                  sp:varName "sub"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ] ;
                sp:arg2 "false"^^xsd:boolean ;
                sp:arg3 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
    ] ;
  rdfs:comment "Given an EM, check if all direct subordinate EMs have created presentAggregationData instances. This boolean function is used to ensure a higher-level EM doesn't define recursive properties until all the subordinate EMs have already done so. A returned value of \"true\" means all direct subordinates have done so."^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
[
  rdf:type sp:Select ;
  sp:resultVariables (
      spin:_arg1
    ) ;
  sp:where (
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      spin:_arg1
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      spin:_arg1
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      spin:_arg1
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:expression [
            rdf:type sp:Sum ;
            sp:expression [
                sp:varName "newVal"^^xsd:string ;
              ] ;
          ] ;
        sp:varName "aggVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject [
            sp:varName "circuit"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
[
  rdf:type sp:Select ;
  sp:resultVariables (
      [
        sp:varName "newVal"^^xsd:string ;
      ]
    ) ;
  sp:where (
      [
        sp:object [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
        sp:predicate rules:getLoadsContributingToCircuit ;
        sp:subject spin:_arg1 ;
      ]
      [
        rdf:type sp:TriplePath ;
        sp:object [
            sp:varName "val"^^xsd:string ;
          ] ;
        sp:path [
            rdf:type sp:SeqPath ;
            sp:path1 [
                rdf:type sp:SeqPath ;
                sp:path1 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/load_component---device_and_model_components#hasActualDemandRef> ;
                sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/power_measurements---measurements#hasQuantityRealPowerRef> ;
              ] ;
            sp:path2 <http://uml.linkedmodels.org/sg/schema/fsgim.rofficial/submodels/measurements---common_primitive_types_classes_and_enumerations#hasValue> ;
          ] ;
        sp:subject [
            sp:varName "componentElement"^^xsd:string ;
          ] ;
      ]
      [
        rdf:type sp:Bind ;
        sp:expression [
            rdf:type spif:cast ;
            sp:arg1 [
                sp:varName "val"^^xsd:string ;
              ] ;
            sp:arg2 xsd:float ;
          ] ;
        sp:variable [
            sp:varName "newVal"^^xsd:string ;
          ] ;
      ]
    ) ;
].
